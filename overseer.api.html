<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>overseer.api documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Overseer 0.8.6 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>overseer</span></div></div></li><li class="depth-2 branch current"><a href="overseer.api.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>api</span></div></a></li><li class="depth-2 branch"><a href="overseer.config.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>config</span></div></a></li><li class="depth-2"><a href="overseer.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="overseer.api.html#var-abort"><div class="inner"><span>abort</span></div></a></li><li class="depth-1"><a href="overseer.api.html#var-abort-silent"><div class="inner"><span>abort-silent</span></div></a></li><li class="depth-1"><a href="overseer.api.html#var-fault"><div class="inner"><span>fault</span></div></a></li><li class="depth-1"><a href="overseer.api.html#var-harness"><div class="inner"><span>harness</span></div></a></li><li class="depth-1"><a href="overseer.api.html#var-install"><div class="inner"><span>install</span></div></a></li><li class="depth-1"><a href="overseer.api.html#var-job-graph"><div class="inner"><span>job-graph</span></div></a></li><li class="depth-1"><a href="overseer.api.html#var-simple-graph"><div class="inner"><span>simple-graph</span></div></a></li><li class="depth-1"><a href="overseer.api.html#var-start"><div class="inner"><span>start</span></div></a></li><li class="depth-1"><a href="overseer.api.html#var-store"><div class="inner"><span>store</span></div></a></li><li class="depth-1"><a href="overseer.api.html#var-transact-graph"><div class="inner"><span>transact-graph</span></div></a></li><li class="depth-1"><a href="overseer.api.html#var-validate-graph-handlers"><div class="inner"><span>validate-graph-handlers</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">overseer.api</h2><div class="doc"><pre class="plaintext">User-facing core API

Jobs are defined as maps with the following attributes:
  :job/id - Required String uniquely identifying a job
  :job/type - Keyword type name of this job
  :job/status - Keyword, one of #{:unstarted :started :finished :failed :aborted}
  :job/args - Optional arguments to the job (must be serializable as EDN)

Jobs that have been run (or attempted) by the system may also have the following attributes:
  :job/heartbeat - Integer UNIX timestamp of the last time a worker processing
                   this job marked itself alive
  :job/failure - Map containing information about the failure of a job

Graphs are defined as Loom digraphs where every node is a valid Job.</pre></div><div class="public anchor" id="var-abort"><h3>abort</h3><div class="usage"><code>(abort msg)</code></div><div class="doc"><pre class="plaintext">Control-flow helper to immediately mark a job as aborted from within a handler
and abort all of its dependents (halts handler execution)
Fails loudly by default - will log an error and and send to Sentry.
See also `abort-silent`</pre></div></div><div class="public anchor" id="var-abort-silent"><h3>abort-silent</h3><div class="usage"><code>(abort-silent msg)</code></div><div class="doc"><pre class="plaintext">Like `abort`, but does not send exceptions to Sentry
</pre></div></div><div class="public anchor" id="var-fault"><h3>fault</h3><div class="usage"><code>(fault msg)</code></div><div class="doc"><pre class="plaintext">Signal that a transient fault has occurred and the worker should
release and unstart the job so that it can be retried at a later time.</pre></div></div><div class="public anchor" id="var-harness"><h3>harness</h3><div class="usage"><code>(harness handler wrapper)</code><code>(harness handler k wrapper)</code></div><div class="doc"><pre class="plaintext">A mechanism to &apos;wrap&apos; job handlers, giving one the ability
to provide additional context, inject dependencies, or otherwise
alter the flow of execution. Conceptually, harnessing is similar to
the idea behind Ring middleware.

Accepts a standard job handler (map or function) and a
`wrapper` function which will be called with the *function* specified
in your handler and is expected to return a new *function* with the
same signature. If your handler is a map, it will be transparently
constructed/deconstructed; harnesses work solely in terms of functions.

For example, a harness that simply implements the default behavior for
a processor is:

  (defn my-harness [f]
    (fn [job]
      (f job)))

A more substantive harness can be used to provide jobs with additional
context or inject dependencies such as a database connection:

  (defn my-harness [f]
    (fn [job]
      (let [modified-job (assoc job :conn (d/connect my-datomic-uri))]
        (f modified-job))))

Or add logging:

  (defn logging-harness [f]
    (fn [job]
      (println &quot;START execution of &quot; (:job/id job))
      (f job)
      (println &quot;FINISH execution of &quot; (:job/id job))))

After defining a harness, in the job-handlers map one specifies

  {:my-job (overseer.api/harness my-job/run my-harness)}

Following the previous example, within your handler you now have
additional context available:

  (defn run [{:keys [conn] :as job}] ...)

If your handler is a map, you can optionally specify a key to harness a
specific stage; the default is :process. For example, to harness
a post-processor:

  {:my-job (overseer.api/harness my-job/run :post-process my-harness)}

If you attempt to harness a missing stage for a given job, the wrapper will
be invoked with a properly-formed identity function, meaning you can write
your harnesses in a single consistent fashion, and, for example, universally
harness a post-processor for a set of handlers that may or may not define
their own post-processor.</pre></div></div><div class="public anchor" id="var-install"><h3>install</h3><div class="usage"><code>(install store)</code></div><div class="doc"><pre class="plaintext">Install store configuration (create system tables, etc). *Not* guaranteed
to be idempotent. Returns :ok on success</pre></div></div><div class="public anchor" id="var-job-graph"><h3>job-graph</h3><div class="usage"><code>(job-graph job-type-graph)</code><code>(job-graph job-type-graph tx)</code></div><div class="doc"><pre class="plaintext">Given a map in Loom adjacency list format specifying dependencies between keyword job types,
and an optional map of additional job data, return a Loom digraph of Job maps that can be
transacted by a store. This assumes you are only generating one job per type.

Ex:
  (def graph (job-graph
              {:start []
               :process-1a [:start]
               :process-1b [:process-1a]
               :process-2 [:start]
               :finish [:process-1b :process-2]}
              {:org/id 123}))
  ; =&gt; Graph&lt;Job&gt;, ex:
  ;    {{:job/id 1 :job/type :start :org/id 123} []
        {:job/id 2 :job/type :process-1a :org/id 123} [{:job/id 1 ...}]
        {:job/id 3 :job/type :process-1b :org/id 123} [{:job/id 2 ...}]
        ...}
  (core/transact-graph store txns graph)</pre></div></div><div class="public anchor" id="var-simple-graph"><h3>simple-graph</h3><div class="usage"><code>(simple-graph &amp; jobs)</code></div><div class="doc"><pre class="plaintext">Construct a Graph from Job(s) that have no dependencies between them
</pre></div></div><div class="public anchor" id="var-start"><h3>start</h3><div class="usage"><code>(start config store job-handlers)</code></div><div class="doc"><pre class="plaintext">Start the system inline given a config map, a Store implementation (see `store`)
and a job-handler map of {job-type job-handler}</pre></div></div><div class="public anchor" id="var-store"><h3>store</h3><div class="usage"><code>(store config)</code></div><div class="doc"><pre class="plaintext">Return a Store implementation based on the store type and type-specific
configuration in `config` map</pre></div></div><div class="public anchor" id="var-transact-graph"><h3>transact-graph</h3><div class="usage"><code>(transact-graph store graph)</code></div><div class="doc"><pre class="plaintext">Given a Graph, atomically transact all of its jobs/dependencies into
the store. See `store`, `job-graph`.</pre></div></div><div class="public anchor" id="var-validate-graph-handlers"><h3>validate-graph-handlers</h3><div class="usage"><code>(validate-graph-handlers handlers job-type-graph)</code></div><div class="doc"><pre class="plaintext">Assert that a given job-type keyword graph (see `job-graph`)
only references handlers defined in the given `handlers` map.</pre></div></div></div></body></html>